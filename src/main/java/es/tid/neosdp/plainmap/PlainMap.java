/*
 * Copyright 2015 Telefónica Investigación y Desarrollo, S.A.U
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.tid.neosdp.plainmap;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility Map to access a hierarchical HashMap (e.g., the Maps generated by parsing a xml or json documents) as a flat
 * map.
 *
 * @author Jorge Lorenzo (jorgelg@tid.es)
 * @author Fernando Jordan Silva (fjordan@aubay.es)
 */
@SuppressWarnings("unchecked")
public class PlainMap {

    private static final char SEPARATOR_DOT = '.';
    private static final char SEPARATOR_ARRAY_START = '[';
    private static final char SEPARATOR_ARRAY_END = ']';
    private static final char SEPARATOR_ASSOCIATIVE_ARRAY_START = '{';
    private static final char SEPARATOR_ASSOCIATIVE_ARRAY_END = '}';
    private static final char SEPARATOR_ASSOCIATIVE_ARRAY_EQUALS = '=';

    private static final String ARRAY_LENGTH = "length";
    private static final String DOT_ARRAY_LENGTH = ".length";
    private static final String EMPTY_STRING = "";

    /**
     * Hierarchical map of the document.
     */
    private Map<String, Object> documentMap;

    /**
     * Default constructor. Creates an empty map.
     */
    public PlainMap() {
        this.documentMap = new HashMap<String, Object>();
    }

    /**
     * Constructor.
     *
     * @param documentMap
     */
    public PlainMap(final Map<String, Object> documentMap) {
        this.documentMap = documentMap;
    }

    /**
     * Constructor. The map is created under a root path.
     *
     * @param documentMap
     * @param rootPath
     */
    public PlainMap(final Map<String, Object> documentMap, final String rootPath) {
        this.documentMap = documentMap;
        this.addRootPath(rootPath);
    }

    /**
     * Get the hierarchical map encapsulated in this object.
     *
     * @return
     */
    public Map<String, Object> getHierarchicalMap() {
        return this.documentMap;
    }

    /**
     * Convert a hierarchical map into a plain map. Create a new instance of the plain map.
     *
     * @param documentMap
     * @return
     */
    public Map<String, String> getPlainMap() {
        return new InternalPlainMap().getPlainMap(this.documentMap);
    }

    /**
     * Check if the path specified actually exists in the plain map.
     *
     * @param path
     * @return
     */
    public boolean exists(final String path) {
        try {
            // Find the last separator (.[{). It starts the search from the right
            for (int i = path.length() - 1; i >= 0; i--) {
                char pathChar = path.charAt(i);
                if (pathChar == PlainMap.SEPARATOR_DOT) {
                    // It corresponds to a parent map. Check if the element exists in the parent map
                    String parentPath = path.substring(0, i);
                    String elementName = path.substring(i + 1);
                    Map<String, Object> parentMap = (Map<String, Object>) this.get(parentPath);
                    return (parentMap != null && parentMap.containsKey(elementName));
                } else if (pathChar == PlainMap.SEPARATOR_ARRAY_START) {
                    // It corresponds to a parent list. Check if the parent list size is higher than the required index
                    String parentPath = path.substring(0, i);
                    int index = Integer.parseInt(path.substring(i + 1, path.length() - 1));
                    List<Object> parentList;
                    if (parentPath.isEmpty()) {
                        parentList = (List<Object>) this.documentMap.get(PlainMap.EMPTY_STRING);
                    } else {
                        parentList = (List<Object>) this.get(parentPath);
                    }
                    return (parentList != null && parentList.size() > index);
                } else if (pathChar == PlainMap.SEPARATOR_ASSOCIATIVE_ARRAY_START) {
                    // Get the value. It needs to be distinct of null if exists
                    return (this.get(path) != null);
                }
            }

            // It is a single element (no separator found)
            return (this.documentMap.containsKey(path));

        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Get an element of the hierarchical map by a plain map path. This method simplifies the access to the information
     * of the hierarchical map. If the path does not map any element in the hierarchical map, then return null. Under
     * any type of error, it is returned a null value.
     *
     * @param path
     * @return
     */
    public Object get(final String path) {
        try {
            // If the first char is '[', then consider that the root element of the map is empty (and contains the list)
            if (path == null || path.isEmpty() || path.charAt(0) == PlainMap.SEPARATOR_ARRAY_START
                    || PlainMap.DOT_ARRAY_LENGTH.equals(path)) {
                return this.getElement(this.documentMap.get(PlainMap.EMPTY_STRING), path);
            } else {
                return this.getElement(this.documentMap, path);
            }
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Put a value in the hierarchical map by a plain map path. It is possible to put a List<Object> or Map<String,
     * Object> values in the plain map; however, these values must be compatible with a PlainMap object (where every
     * leave node is a String) and this is not validated by this method. Undefined behavior may happen if it is put a
     * List or Map with an incompatible type.
     *
     * @param path
     * @param value
     * @throws PlainMapException
     */
    public void put(final String path, final Object value) throws PlainMapException {
        if (value instanceof PlainMap) {
            this.putMapElement(this.documentMap, path, ((PlainMap) value).documentMap);
        } else {
            this.putMapElement(this.documentMap, path, value);
        }
    }

    /**
     * Clear the plain map.
     */
    public void clear() {
        this.documentMap.clear();
    }

    /**
     * Remove an element (or elements) under the path specified. If the path does not match any element,
     * the action is ignored (without throwing any exception).
     *
     * @param path
     * @throws PlainMapException
     */
    public void remove(final String path) throws PlainMapException {
        if (path == null || path.isEmpty()) {
            this.documentMap.remove(PlainMap.EMPTY_STRING);
            return;
        }
        // Check if it is a list element to be removed or a map element
        if (path.charAt(path.length() - 1) == PlainMap.SEPARATOR_ARRAY_END) {
            // List element
            // Find the list path and the array index
            int startListIndex = path.lastIndexOf(PlainMap.SEPARATOR_ARRAY_START);
            if (startListIndex < 0) {
                throw new PlainMapException("Error removing an element with a wrong path: " + path);
            } else {
                // Get the list
                String listPath = path.substring(0, startListIndex);
                Object listObject = this.get(listPath);
                if (listObject == null) {
                    // The element does not exist. Ignore the action
                    return;
                }
                if (!(listObject instanceof List<?>)) {
                    throw new PlainMapException("The path: " + path + " targets a list but it is not a list");
                }
                // Get the array index
                int listIndex;
                try {
                    listIndex = Integer.parseInt(path.substring(startListIndex + 1, path.length() - 1));
                } catch (NumberFormatException e) {
                    throw new PlainMapException("The path: " + path + " specifies a wrong list index", e);
                }
                // Remove the list element
                List<Object> list = (List<Object>) listObject;
                if (list.size() > listIndex) {
                    list.remove(listIndex);
                }
                return;
            }
        } else {
            // Map element
            // Get the parent map
            int endParentPathIndex = path.lastIndexOf(PlainMap.SEPARATOR_DOT);
            String mapPath = endParentPathIndex < 0 ? PlainMap.EMPTY_STRING : path.substring(0, endParentPathIndex);
            Object mapObject = mapPath.isEmpty() ? this.getHierarchicalMap() : this.get(mapPath);
            if (mapObject == null) {
                // The map does not exist. Ignore the action
                return;
            }
            if (!(mapObject instanceof Map<?, ?>)) {
                throw new PlainMapException("The path: " + path + " targets a map but it is not a map");
            }
            // Get the map key (to be removed)
            String mapKey = path.substring(endParentPathIndex + 1);
            // Remove the map element
            Map<String, Object> map = (Map<String, Object>) mapObject;
            map.remove(mapKey);
            if (map.isEmpty()) {
                // Remove the map as well assigning the value null
                this.put(mapPath, null);
            }
        }
    }

    /**
     * Add a root path to every element in the map.
     *
     * @param rootPath
     */
    public final void addRootPath(final String rootPath) {
        if (rootPath == null || rootPath.isEmpty()) {
            return;
        }
        Map<String, Object> newDocumentMap = new HashMap<String, Object>();
        Object val = this.documentMap.containsKey(PlainMap.EMPTY_STRING) ? this.documentMap.get(PlainMap.EMPTY_STRING)
                : this.documentMap;
        this.putMapElement(newDocumentMap, rootPath, val);
        this.documentMap = newDocumentMap;
    }

    /**
     * Remove a root path reducing the hierarchy of the map.
     *
     * It clears the map and assign to the map the value at rootPath.
     *
     * @param rootPath
     * @throws PlainMapException
     */
    public void removeRootPath(final String rootPath) throws PlainMapException {
        if (this.exists(rootPath)) {
            Object rootPathValue = this.get(rootPath);
            this.documentMap.clear();
            this.put(null, rootPathValue);
        } else {
            this.documentMap.clear();
        }
    }

    /**
     * Get the parent element name. If there is any problem or there is not one and only one element, then return null.
     *
     * @return
     * @throws PlainMapException
     */
    public String getParent() throws PlainMapException {
        if (this.documentMap.size() != 1) {
            throw new PlainMapException("There is not one and only one parent element in the document map");
        }
        return this.documentMap.keySet().iterator().next();
    }

    /**
     * Extract the parent element. The map is modified after the extraction of the root element and this root element
     * name is returned.
     *
     * @return
     * @throws PlainMapException
     */
    public String extractParent() throws PlainMapException {
        String parent = this.getParent();
        Object newObject = this.documentMap.get(parent);
        // Clear the map and put the newObject at the root of the plainmap
        this.documentMap.clear();
        this.put(null, newObject);
        return parent;
    }

    /**
     * Get the element value for a specific path by querying the elementObject (typically a Map<String, Object>, but it
     * could also be a List<Object> or a String).
     *
     * This path may include any separator: .[{ inside the elementPath.
     *
     * @param elementObject
     * @param elementPath
     * @return
     * @throws PlainMapException
     */
    private Object getElement(Object elementObject, final String elementPath) throws PlainMapException {
        if (elementPath == null || elementPath.isEmpty()) {
            return elementObject;
        }
        // If the first char in the elementPath is a "dot", do not consider it
        if (elementPath.charAt(0) == PlainMap.SEPARATOR_DOT) {
            return this.getElement(elementObject, elementPath.substring(1));
        }
        // Get the index to the separators: {[
        int bracketIndex = elementPath.indexOf(PlainMap.SEPARATOR_ASSOCIATIVE_ARRAY_START);
        int sqBracketIndex = elementPath.indexOf(PlainMap.SEPARATOR_ARRAY_START);
        // Check if there is any bracket
        if (bracketIndex == -1 && sqBracketIndex == -1) {
            // No bracket. Only normal path element
            return this.getElementFromMapPath(elementObject, elementPath);
        } else {
            if (bracketIndex != -1) {
                // Associative array: path1.path2{key=value}.path3
                String associativeArrayPath = elementPath.substring(bracketIndex);
                List<Map<String, Object>> associativeList = (List<Map<String, Object>>) this.getElement(elementObject,
                        elementPath.substring(0, bracketIndex));
                return this.getElementFromAssociativeArrayPath(associativeList, associativeArrayPath);
            } else {
                // Array: path1.path2[2].path3
                String arrayPath = elementPath.substring(sqBracketIndex);
                Object arrayObject = this.getElement(elementObject, elementPath.substring(0, sqBracketIndex));
                return this.getElementFromArrayPath(arrayObject, arrayPath);
            }
        }
    }

    /**
     * Process a path (without any special bracket separator). The only separator permitted in this method is the "dot".
     * It iterates through the path elements by querying sequentially the maps.
     *
     * @param elementObject
     * @param elementMapPath
     * @return
     * @throws PlainMapException
     */
    private Object getElementFromMapPath(final Object elementObject,
            final String elementMapPath) throws PlainMapException {
        int index = 0;
        Object currentElementObject = elementObject;
        while (true) {
            int newIndex = elementMapPath.indexOf(PlainMap.SEPARATOR_DOT, index);
            if (newIndex >= 0) {
                String pathElement = elementMapPath.substring(index, newIndex);
                currentElementObject = ((Map<String, ?>) currentElementObject).get(pathElement);
                if (currentElementObject == null) {
                    return null;
                }
                index = newIndex + 1;
            } else {
                // No more elements
                String pathElement = elementMapPath.substring(index);
                if (PlainMap.ARRAY_LENGTH.equals(pathElement)) {
                    return Integer.toString(((List<?>) currentElementObject).size());
                } else {
                    return ((Map<String, ?>) currentElementObject).get(pathElement);
                }
            }
        }
    }

    /**
     * Process the path for an associative array. The path starts with the format: {key=value}.xxx. This notation is a
     * shortcut to handle lists of maps where it is required to query the map that matches a specific value. This method
     * returns the map that matches the value.
     *
     * @param associativeList
     * @param associativeArrayPath
     * @return
     * @throws PlainMapException
     */
    private Object getElementFromAssociativeArrayPath(List<Map<String, Object>> associativeList,
            String associativeArrayPath) throws PlainMapException {
        int endAssociativeArrayIndex = associativeArrayPath.indexOf(PlainMap.SEPARATOR_ASSOCIATIVE_ARRAY_END);
        if (endAssociativeArrayIndex < 0) {
            throw new PlainMapException("The associative array query must be surrounded by brackets: "
                    + associativeArrayPath);
        }
        // Get the associative query (between brackets)
        int equalsIndex = associativeArrayPath.indexOf(PlainMap.SEPARATOR_ASSOCIATIVE_ARRAY_EQUALS);
        if (equalsIndex < 0) {
            throw new PlainMapException("Invalid associative array query: " + associativeArrayPath);
        }
        String associativeMapKey = associativeArrayPath.substring(1, equalsIndex);
        String associativeMapValue = associativeArrayPath.substring(equalsIndex + 1, endAssociativeArrayIndex);
        // Iterate through the list to find the list element mapping the associative query
        for (Map<String, Object> associativeMap : associativeList) {
            if (associativeMapValue.equals(associativeMap.get(associativeMapKey))) {
                return this.getElement(associativeMap, associativeArrayPath.substring(endAssociativeArrayIndex + 1));
            }
        }
        // Not found the element matching the associative array query
        return null;
    }

    /**
     * Process an array index returning the array element value. The parameter "arrayPath" is a string with the array
     * index and the rest of the path (e.g. "[3]", "[0].element", or "[0][2].element").
     *
     * @param arrayObject
     * @param arrayPath
     * @return
     */
    private Object getElementFromArrayPath(final Object arrayObject, String arrayPath) throws PlainMapException {
        int endArrayIndex = arrayPath.indexOf(PlainMap.SEPARATOR_ARRAY_END);
        if (endArrayIndex < 0) {
            throw new PlainMapException("The array query must be surrounded by square brackets: " + arrayPath);
        }
        try {
            int arrayIndex = Integer.parseInt(arrayPath.substring(1, endArrayIndex));
            String subarrayPath = arrayPath.substring(endArrayIndex + 1);
            // Check if the array object is a list
            if (arrayObject instanceof List<?>) {
                Object subarrayObject = ((List<Object>) arrayObject).get(arrayIndex);
                return this.getElement(subarrayObject, subarrayPath);
            } else {
                if (arrayIndex == 0) {
                    return this.getElement(arrayObject, subarrayPath);
                } else {
                    return null;
                }
            }
        } catch (NumberFormatException e) {
            throw new PlainMapException("The array query requires an integer index: " + arrayPath, e);
        }
    }

    /**
     * Put a value in the map for the corresponding plain path. It iterates through the elements of the path, and it
     * adds any Map or List required to arrive to the path. The array elements are handled by prepareArrayElement.
     *
     * @param map
     * @param path
     * @param value
     */
    private void putMapElement(final Map<String, Object> map, final String path, final Object value) {
        if (path == null || path.isEmpty()) {
            if (value instanceof Map) {
                map.putAll((Map<String, Object>) value);
            } else {
                map.put(PlainMap.EMPTY_STRING, value);
            }
        } else {
            // Get the first element of the parentPath
            int index = path.indexOf(PlainMap.SEPARATOR_DOT);
            String firstPathElement = (index >= 0) ? path.substring(0, index) : path;
            String childPath = (index >= 0) ? path.substring(index + 1) : PlainMap.EMPTY_STRING;
            // Get the element name in the map (removing the array stuff if exists)
            int startArrayIndex = firstPathElement.indexOf(PlainMap.SEPARATOR_ARRAY_START);
            String subElementName = (startArrayIndex >= 0) ? firstPathElement.substring(0, startArrayIndex)
                    : firstPathElement;
            Object subElementObject = map.get(subElementName);
            Map<String, Object> subElementMap = null;
            // Return the map. It is managed differently if the element is simple or an array
            if (startArrayIndex < 0) {
                if (childPath.isEmpty()) {
                    map.put(subElementName, value);
                } else {
                    // Check if it already exists. Otherwise, create it
                    if (subElementObject == null) {
                        subElementMap = new HashMap<String, Object>();
                        map.put(subElementName, subElementMap);
                    } else {
                        subElementMap = (Map<String, Object>) subElementObject;
                    }
                }
            } else {
                // Manage the array stuff
                if (!(subElementObject instanceof List<?>)) {
                    // Create the array
                    subElementObject = new ArrayList<Object>();
                    map.put(subElementName, subElementObject);
                }
                Object arrayValue = childPath.isEmpty() ? value : null;
                subElementMap = this.prepareArrayElement((List<Object>) subElementObject,
                        firstPathElement.substring(startArrayIndex), arrayValue);
            }
            if (!childPath.isEmpty()) {
                this.putMapElement(subElementMap, childPath, value);
            }
        }
    }

    /**
     * Iterates through the array indexes to generate/get the lists. The parameter "arrayPath" is a string with the
     * array indexes (e.g. "[3]" or "[0][2]"). If the parameter "value" is not null, when arriving to the last array
     * index, the value is set in that list.
     *
     * @param arrayElementObject
     * @param arrayPath
     * @param value
     * @return
     */
    private Map<String, Object> prepareArrayElement(final List<Object> arrayElementObject, final String arrayPath,
            final Object value) {
        int endArrayIndex = arrayPath.indexOf(PlainMap.SEPARATOR_ARRAY_END);
        int arrayIndex = Integer.parseInt(arrayPath.substring(1, endArrayIndex));
        String subarrayPath = arrayPath.substring(endArrayIndex + 1);
        if (arrayIndex >= arrayElementObject.size()) {
            // Add null elements if they don't already exist in order to reach to the arrayIndex
            for (int j = arrayElementObject.size(); j < arrayIndex; j++) {
                arrayElementObject.add(null);
            }
            if (subarrayPath.isEmpty()) {
                if (value == null) {
                    Map<String, Object> subarrayMap = new HashMap<String, Object>();
                    arrayElementObject.add(subarrayMap);
                    return subarrayMap;
                } else {
                    arrayElementObject.add(value);
                    return null;
                }
            } else {
                List<Object> subarrayList = new ArrayList<Object>();
                arrayElementObject.add(subarrayList);
                return this.prepareArrayElement(subarrayList, subarrayPath, value);
            }
        } else {
            // The element already exists
            if (subarrayPath.isEmpty()) {
                if (value == null) {
                    Object subarrayObject = arrayElementObject.get(arrayIndex);
                    if (!(subarrayObject instanceof Map<?, ?>)) {
                        subarrayObject = new HashMap<String, Object>();
                        arrayElementObject.set(arrayIndex, subarrayObject);
                    }
                    return (Map<String, Object>) subarrayObject;
                } else {
                    arrayElementObject.set(arrayIndex, value);
                    return null;
                }
            } else {
                return this.prepareArrayElement((List<Object>) arrayElementObject.get(arrayIndex), subarrayPath, value);
            }
        }
    }

    /**
     * Internal class to create a plain map which maps a hierarchical map.
     *
     * This class is used by the method getPlainMap.
     *
     * @author Jorge Lorenzo (jorgelg@tid.es)
     */
    private class InternalPlainMap {
        private Map<String, String> plainMap;

        public Map<String, String> getPlainMap(Map<String, Object> documentMap) {
            this.plainMap = new HashMap<String, String>();
            this.fillPlainMapForObject(PlainMap.EMPTY_STRING, documentMap);
            return this.plainMap;
        }

        private void fillPlainMapForObject(String parentElementName, Map<String, Object> documentMap) {
            for (Map.Entry<String, Object> elementEntry : documentMap.entrySet()) {
                String rootElementName = (parentElementName.isEmpty()) ? elementEntry.getKey() : parentElementName
                        + PlainMap.SEPARATOR_DOT + elementEntry.getKey();
                this.fillPlainMapForValue(rootElementName, elementEntry.getValue());
            }
        }

        private void fillPlainMapForValue(String elementName, Object elementValue) {
            if (elementValue instanceof List<?>) {
                List<Object> elementList = (List<Object>) elementValue;
                for (int i = 0; i < elementList.size(); i++) {
                    String arrayElementName = elementName + PlainMap.SEPARATOR_ARRAY_START + i
                            + PlainMap.SEPARATOR_ARRAY_END;
                    this.fillPlainMapForValue(arrayElementName, elementList.get(i));
                }
                String arrayElementLength = elementName + PlainMap.DOT_ARRAY_LENGTH;
                this.plainMap.put(arrayElementLength, Integer.toString(elementList.size()));
            } else if (elementValue instanceof Map<?, ?>) {
                this.fillPlainMapForObject(elementName, (Map<String, Object>) elementValue);
            } else {
                String stringValue = (elementValue == null) ? null : elementValue.toString();
                this.plainMap.put(elementName, stringValue);
            }
        }
    }
}
